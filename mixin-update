#!/usr/bin/env python

import argparse
import ConfigParser
import sys
import os
import os.path
import re
import argparse
import collections
import string

# We're assuming '#' is valid to start a comment in all the configs we are amending
# which so far is true.
_MIXIN_HEADER = "# ----------------- BEGIN MIX-IN DEFINITIONS -----------------\n"
_MIXIN_FOOTER = "# ------------------ END MIX-IN DEFINITIONS ------------------\n"
_MIXIN_SOURCE = "# Source: "
_MIXIN_LINE   = "##############################################################\n"
_MIXIN_WARN   = "# Mix-In definitions are auto-generated by "

# These are the set of product configuration files that are modified by mixins.
# If they are named something else in the actual product directory, the mixin spec
# file should setup the mapping in the "mapping" section
_FILE_LIST = ["BoardConfig.mk", "init.rc", "init.recovery.rc", "fstab", "product.mk",
    "ueventd.rc", "AndroidBoard.mk"]

_PRODUCT_SPEC_FN = "mixins.spec"
_GROUP_SPEC_FN = "mixinfo.spec"

abort_on_errors = True
policy_errors_found = False

class ParameterFormatter(string.Formatter):
    RE = re.compile(r"""
        (.*?(?=\$\[\w+\]) # optional text followed by a field
        |.+?(?=\Z))       # or text followed by an end-of-string
        (?:               # Possible field_name
            \$\[
            (\w+)
            \]
        )?""", re.VERBOSE | re.DOTALL)

    def __init__(self):
        self.kwargs = set()
        self.used_args = set()

    def parse(self, format_string):
        for literal_text, field_name in self.RE.findall(format_string):
            if field_name == '':
                yield (literal_text, None, None, None)
            else:
                yield (literal_text, field_name, '', None)

    def check_unused_args(self, used_args, args, kwargs):
        self.used_args |= used_args
        self.kwargs |= set(kwargs.keys())

    def error_on_unused_args(self, option):
        unused = list(self.kwargs - self.used_args)
        if unused:
            policy_error("Unnecessary parameter {} given for mixin option '{}'".format(unused, option))


def warning(s):
    sys.stderr.write(s + "\n");
    sys.stderr.flush()


def policy_error(s):
    global policy_errors_found
    sys.stderr.write("ERROR: ")
    warning(s)
    if abort_on_errors:
        sys.exit(1)
    else:
        policy_errors_found = True


def read_spec_file(specfile, cp=None):
    """read a mixin spec file and return a ConfigParser object with its
    definitions. If a ConfigParser is supplied as an argument, it will
    be augmented with the new data"""
    if not cp:
        cp = ConfigParser.SafeConfigParser()

    with open(specfile) as fp:
        cp.readfp(fp)

    return cp


def read_mixin_tree(basedir, mixin_tree=None):
    """return a dictionary mapping mixin groups found in a particular
    basedir with a dictionary mapping option names to the directory
    containing their configuration fragments as well as other group-level
    metadata"""

    if not mixin_tree:
        mixin_tree = {}

    groups = [i for i in os.listdir(basedir) if not i.startswith(".")]
    for group in groups:
        assert group not in mixin_tree
        mixin_tree[group] = {}
        groupdir = os.path.join(basedir, group)
        mixin_tree[group]["groupdir"] = groupdir
        mixin_tree[group]["options"] = {}
        mixin_tree[group]["deps"] = []

        # Check for a mixinfo file in the root of the group directory
        # This is for metadata about the group as a whole. Its presence
        # is optional, many groups won't need it.
        mixinfo = os.path.join(groupdir, _GROUP_SPEC_FN)
        if os.path.exists(mixinfo):
            cp = read_spec_file(mixinfo)

            # "mixinfo.deps" is the set of groups which must be inherited
            # prior to inheriting this mixin, typically because we need the
            # other groups to define certain variables for us
            if cp.has_option("mixinfo", "deps"):
                mixin_tree[group]["deps"] = cp.get("mixinfo", "deps").split()

        options = [i for i in os.listdir(groupdir) if not i.startswith(".")]
        for option in options:
            optiondir = os.path.join(groupdir, option)
            assert option not in mixin_tree[group]["options"]
            mixin_tree[group]["options"][option] = optiondir

    return mixin_tree


def validate_selections(selections, mixin_tree, verbose=False):
    """enforce that the set of mixin selections is sane by checking
    the following:
    1) For each group selected, verify that the group exists and that
    the particular selection made within that group also exists
    2) If any groups exist for which there is no selection made, make
    the default selection for that group. If no default exists, report an
    error.
    The selections list may be altered by this function to include
    group default selections"""

    groups_seen = []
    returned_selections = []

    for (group, option, params) in selections:
        if group in groups_seen:
            policy_error("selection already made for group {}".format(group))
            continue

        groups_seen.append(group)

        if group not in mixin_tree:
            policy_error("no definition found for group {}".format(group))
            continue

        if option not in mixin_tree[group]["options"]:
            policy_error("unknown option {} for group {}".format(option, group))
            continue

        deps = mixin_tree[group]["deps"]
        for dep in deps:
            if dep not in groups_seen:
                policy_error("group {} requires that group {} be selected first".format(group, dep))

        returned_selections.append((group, option, params))

    # The spec file may have omitted some groups. If so, pull in their
    # default options, or generate an error if there is no default
    unspecified_groups = set(mixin_tree.keys()) - set(groups_seen)
    for group in unspecified_groups:
        if verbose:
            warning("group {} exists but not specified, using default option".format(group))
        if "default" not in mixin_tree[group]["options"]:
            if not silence:
                policy_error("group {} doesn't have a default option!".format(group))
        else:
            returned_selections.append((group, "default", {}))

    return returned_selections


def clear_file(dest):
    """Return of list of string lines based on the destination file.
    Clear out any existing mixin defintions from the specified file; after this
    is done only the header/footer will remain. If the dest file never had anything
    in it, add the header/footer"""
    output = []
    in_mixin = False
    ever_in_mixin = False

    if os.path.exists(dest):
        with open(dest) as dfile:
            dlines = dfile.readlines()
    else:
        dlines = []

    orig_dlines = dlines[:]

    for line in dlines:
        if not in_mixin:
            output.append(line)
            if line == _MIXIN_HEADER:
                in_mixin = True
                ever_in_mixin = True
                output.append(_MIXIN_WARN + os.path.basename(sys.argv[0]) + '\n')
        else:
            if line == _MIXIN_FOOTER:
                output.append(line)
                in_mixin = False

    if in_mixin:
        # header with no footer? ok whatever
        output.append(_MIXIN_FOOTER)

    if not ever_in_mixin:
        output.append(_MIXIN_HEADER)
        output.append(_MIXIN_WARN + os.path.basename(sys.argv[0]) + '\n')
        output.append(_MIXIN_FOOTER)

    return orig_dlines, output


warn_vars = [
        "ADDITIONAL_BUILD_PROPERTIES",
        "ADDITIONAL_DEFAULT_PROPERTIES",
        "BOARD_KERNEL_CMDLINE",
        "DEVICE_PACKAGE_OVERLAYS",
        "PRODUCT_COPY_FILES",
        "PRODUCT_DEFAULT_PROPERTY_OVERRIDES",
        "PRODUCT_PACKAGES",
        "PRODUCT_PACKAGES_DEBUG",
        "PRODUCT_PACKAGES_ENG",
        "PRODUCT_PACKAGES_TESTS",
        "PRODUCT_PACKAGE_OVERLAYS",
        "PRODUCT_PROPERTY_OVERRIDES",
        ]

def amend_file(dlines, src, mixinsbase, params, formatter):
    """Augment the destination lines list with data from the source file provided.
    Assumes we have run clear_file() on dlines at some point beforehand"""
    with open(src) as sfile:
        slines = sfile.readlines()
        try:
            slines = [formatter.vformat(i, (), params) for i in slines]
        except KeyError as e:
            policy_error("{} depends on undefined mixin parameter '{}'".format(src, e.message))

    # sanity checks
    for line in slines:
        if mixinsbase in line:
            policy_error("build-time references to paths inside mixin directory are not allowed; {} is invalid".format(src))
        m = re.search("(\w*)\s*[:][=]", line)
        if m:
            vname = m.groups()[0]
            if vname in warn_vars:
                warning("Non-accumulative assignment to '{}' found in {}".format(vname, src))

    output = []
    for line in dlines:
        if line == _MIXIN_FOOTER:
            output.append(_MIXIN_LINE)
            output.append(_MIXIN_SOURCE + src + "\n")
            output.append(_MIXIN_LINE)
            output.extend(slines)
        output.append(line)

    return output


def split_params(selections):
    res = []
    for group, option_params in selections:
        m = re.match('(\w+)\s*\(([^)]*)\)\s*$', option_params)
        if m is not None:
            option = m.group(1)
            params = dict(map(str.strip, x.split('=', 1)) for x in m.group(2).split(','))
            res.append((group, option, params))
        else:
            res.append((group, option_params, {}))
    return res


def process_spec_file(specfile, dry_run):
    cp = read_spec_file(specfile)
    basedir = cp.get("main", "mixinsdir")
    selections = split_params(cp.items("groups"))
    mixin_tree = read_mixin_tree(basedir)
    product_dir = os.path.dirname(specfile)
    file_map = {}
    formatters = collections.defaultdict(ParameterFormatter)
    retval = True

    # Set up the file map since the config files in the product directory
    # may have slightly different names than what is in _FILE_LIST
    for fname in _FILE_LIST:
        if cp.has_option("mapping", fname):
            file_map[fname] = cp.get("mapping", fname)
        else:
            file_map[fname] = fname

    # After this, all default selections should be populated
    # and the selections should be sane
    selections = validate_selections(selections, mixin_tree, not dry_run)

    for src, dest in file_map.iteritems():
        dest_fn = os.path.join(product_dir, dest)

        orig_dest_lines, dest_lines = clear_file(dest_fn)

        # Now check all the groups to see if they have a configuration
        # fragment to insert into the destination file
        for group, option, params in selections:
            optdir = mixin_tree[group]["options"][option]
            src_fn = os.path.join(optdir, src)

            # Any given file can have multiple fragments. We first
            # look for <frag>.1, <frag>.2, ... <frag>.9, <frag>
            # This is useful for when several mixin options have mostly
            # the same data except for maybe a few lines; you can
            # avoid copypasting a lot of stuff by using this feature
            # and symbolic links for the common bits.
            frags = [src_fn + "." + str(i) for i in range(10)]
            frags.append(src_fn)

            for frag in frags:
                if os.path.exists(frag):
                    dest_lines = amend_file(dest_lines, frag, basedir, params, formatters[group])

        if dry_run:
            if cmp(dest_lines, orig_dest_lines) != 0:
                warning("{} is out of date".format(dest_fn))
                retval = False
        else:
            with open(dest_fn, "w") as fp:
                fp.writelines(dest_lines)

    for group, option, _ in selections:
        formatters[group].error_on_unused_args(group + ": " + option)

    return retval


def find_all_spec_files(basepath):
    """find all the mixin spec files underneath the specified
    directory (typically device/) and return a list of paths to
    them"""
    ret = []
    for root, dirs, files in os.walk(basepath):
        if "mixins.spec" in files:
            ret.append(os.path.join(root, _PRODUCT_SPEC_FN))
    return ret


def main(dry_run=False, sfiles=None, warn_only=False):
    global abort_on_errors

    ret = 0
    abort_on_errors = not warn_only
    out_of_sync = False

    if not sfiles:
        sfiles = find_all_spec_files("device/intel")

    for sf in sfiles:
        if not process_spec_file(sf, dry_run):
            out_of_sync = True

    if out_of_sync:
        warning("Board configs are out of sync with mixins, please run mixin-update")
        ret = 3

    if policy_errors_found:
        warning("Some spec files have policy issues")
        ret = 2

    return ret


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Update board configurations with mixin data based on spec file")
    parser.add_argument("-d", "--dry-run",
            help="Don't make any actual changes, exit nonzero if something needs to be updated",
            action="store_true")
    parser.add_argument("-s", "--spec",
            help="Read a specific spec file. Can be called multiple times. Defaults to scanning the tree under device/intel/ for spec files",
            action="append")
    parser.add_argument("-w", "--warn-only",
            help="Generate warnings instead of fatal errors for spec file policy violations",
            action="store_true")

    args = parser.parse_args()

    ret = main(args.dry_run, args.spec, args.warn_only)
    sys.exit(ret)

