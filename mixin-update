#!/usr/bin/env python

import argparse
import ConfigParser
import sys
import os
import os.path
import re
import hashlib
import argparse

# We're assuming '#' is valid to start a comment in all the configs we are amending
# which so far is true.
_MIXIN_HEADER = "# ----------------- BEGIN MIX-IN DEFINITIONS -----------------\n"
_MIXIN_FOOTER = "# ------------------ END MIX-IN DEFINITIONS ------------------\n"
_MIXIN_SOURCE = "# Source: "
_MIXIN_LINE   = "##############################################################\n"
_MIXIN_WARN   = "# Mix-In definitions are auto-generated by "

# These are the set of product configuration files that are modified by mixins.
# If they are named something else in the actual product directory, the mixin spec
# file should setup the mapping in the "mapping" section
_FILE_LIST = ["BoardConfig.mk", "init.rc", "init.recovery.rc", "fstab", "product.mk",
    "ueventd.rc", "AndroidBoard.mk"]

_PRODUCT_SPEC_FN = "mixins.spec"
_GROUP_SPEC_FN = "mixinfo.spec"
_HASH_FILE = "mixins.hash"

def warning(s):
    sys.stderr.write(s + "\n");
    sys.stderr.flush()


def die(s):
    warning(s)
    assert False


def hash_directory(specfile, base_path):
    h = hashlib.sha1()

    with open(specfile) as fp:
        h.update(specfile + fp.read())

    for dirpath, dirnames, filenames in os.walk(base_path, topdown=True, followlinks=True):
        # skip dot directories
        dirnames[:] = [dirname for dirname in dirnames if not dirname.startswith(".")]
        for filename in filenames:
            if filename.startswith("."):
                continue
            fname = os.path.join(dirpath, filename)
            with open(fname) as fp:
                h.update(fname + fp.read())
    return h.hexdigest()


def read_spec_file(specfile, cp=None):
    """read a mixin spec file and return a ConfigParser object with its
    definitions. If a ConfigParser is supplied as an argument, it will
    be augmented with the new data"""
    if not cp:
        cp = ConfigParser.SafeConfigParser()

    with open(specfile) as fp:
        cp.readfp(fp)

    return cp


def read_mixin_tree(basedir, mixin_tree=None):
    """return a dictionary mapping mixin groups found in a particular
    basedir with a dictionary mapping option names to the directory
    containing their configuration fragments as well as other group-level
    metadata"""

    if not mixin_tree:
        mixin_tree = {}

    groups = [i for i in os.listdir(basedir) if not i.startswith(".")]
    for group in groups:
        assert group not in mixin_tree
        mixin_tree[group] = {}
        groupdir = os.path.join(basedir, group)
        mixin_tree[group]["groupdir"] = groupdir
        mixin_tree[group]["options"] = {}
        mixin_tree[group]["deps"] = []

        # Check for a mixinfo file in the root of the group directory
        # This is for metadata about the group as a whole. Its presence
        # is optional, many groups won't need it.
        mixinfo = os.path.join(groupdir, _GROUP_SPEC_FN)
        if os.path.exists(mixinfo):
            cp = read_spec_file(mixinfo)

            # "mixinfo.deps" is the set of groups which must be inherited
            # prior to inheriting this mixin, typically because we need the
            # other groups to define certain variables for us
            if cp.has_option("mixinfo", "deps"):
                mixin_tree[group]["deps"] = cp.get("mixinfo", "deps").split()

        options = [i for i in os.listdir(groupdir) if not i.startswith(".")]
        for option in options:
            optiondir = os.path.join(groupdir, option)
            assert option not in mixin_tree[group]["options"]
            mixin_tree[group]["options"][option] = optiondir

    return mixin_tree


def validate_selections(selections, mixin_tree):
    """enforce that the set of mixin selections is sane by checking
    the following:
    1) For each group selected, verify that the group exists and that
    the particular selection made within that group also exists
    2) If any groups exist for which there is no selection made, make
    the default selection for that group. If no default exists, report an
    error.
    The selections list may be altered by this function to include
    group default selections"""

    groups_seen = []

    for (group, option) in selections:
        if group in groups_seen:
            die("selection already made for group {}".format(group))
        groups_seen.append(group)

        if group not in mixin_tree:
            die("no definition found for group {}".format(group))

        if option not in mixin_tree[group]["options"]:
            die("unknown option {} for group {}".format(option, group))

        deps = mixin_tree[group]["deps"]
        for dep in deps:
            if dep not in groups_seen:
                die("group {} requires that group {} be selected first".format(group, dep))

    # The spec file may have omitted some groups. If so, pull in their
    # default options, or generate an error if there is no default
    unspecified_groups = set(mixin_tree.keys()) - set(groups_seen)
    for group in unspecified_groups:
        warning("group {} exists but not specified, using default option".format(group))
        if "default" not in mixin_tree[group]["options"]:
            die("group {} doesn't have a default option!".format(group))
        selections.append((group, "default"))


def clear_file(dest):
    """Clear out any existing mixin defintions from the specified file; after this
    is done only the header/footer will remain. If the dest file never had anything
    in it, add the header/footer. If the dest file didn't exist, create it."""
    output = []
    in_mixin = False
    ever_in_mixin = False

    if os.path.exists(dest):
        with open(dest) as dfile:
            dlines = dfile.readlines()
    else:
        dlines = []

    for line in dlines:
        if not in_mixin:
            output.append(line)
            if line == _MIXIN_HEADER:
                in_mixin = True
                ever_in_mixin = True
                output.append(_MIXIN_WARN + os.path.basename(sys.argv[0]) + '\n')
        else:
            if line == _MIXIN_FOOTER:
                output.append(line)
                in_mixin = False

    if in_mixin:
        # header with no footer? ok whatever
        output.append(_MIXIN_FOOTER)

    if not ever_in_mixin:
        output.append(_MIXIN_HEADER)
        output.append(_MIXIN_WARN + os.path.basename(sys.argv[0]) + '\n')
        output.append(_MIXIN_FOOTER)

    with open(dest, "w") as dfile:
        dfile.writelines(output)

warn_vars = [
        "ADDITIONAL_BUILD_PROPERTIES",
        "ADDITIONAL_DEFAULT_PROPERTIES",
        "BOARD_KERNEL_CMDLINE",
        "DEVICE_PACKAGE_OVERLAYS",
        "DEVICE_PACKAGE_OVERLAYS",
        "PRODUCT_COPY_FILES",
        "PRODUCT_DEFAULT_PROPERTY_OVERRIDES",
        "PRODUCT_PACKAGES",
        "PRODUCT_PACKAGES_DEBUG",
        "PRODUCT_PACKAGES_ENG",
        "PRODUCT_PACKAGES_TESTS",
        "PRODUCT_PACKAGE_OVERLAYS",
        "PRODUCT_PROPERTY_OVERRIDES",
        "PRODUCT_PROPERTY_OVERRIDES",
        ]

def amend_file(dest, src, mixinsbase):
    """Augment the destination file with data from the source file provided.
    Assumes we have run clear_file() on dest at some point beforehand"""
    with open(src) as sfile:
        slines = sfile.readlines()
    with open(dest) as dfile:
        dlines = dfile.readlines()

    # sanity checks
    for line in slines:
        if mixinsbase in line:
            die("build-time references to paths inside mixin directory are not allowed; {} is invalid".format(src))
        m = re.search("(\w*)\s*[:][=]", line)
        if m:
            vname = m.groups()[0]
            if vname in warn_vars:
                warning("Non-accumulative assignment to '{}' found in {}".format(vname, src))

    output = []
    for line in dlines:
        if line == _MIXIN_FOOTER:
            output.append(_MIXIN_LINE)
            output.append(_MIXIN_SOURCE + src + "\n")
            output.append(_MIXIN_LINE)
            output.extend(slines)
        output.append(line)

    with open(dest, "w") as dfile:
        dfile.writelines(output)


def process_spec_file(specfile):
    cp = read_spec_file(specfile)
    basedir = cp.get("main", "mixinsdir")
    selections = cp.items("groups")
    mixin_tree = read_mixin_tree(basedir)
    mixins_hash = hash_directory(specfile, basedir)
    product_dir = os.path.dirname(specfile)
    file_map = {}

    # Set up the file map since the config files in the product directory
    # may have slightly different names than what is in _FILE_LIST
    for fname in _FILE_LIST:
        if cp.has_option("mapping", fname):
            file_map[fname] = cp.get("mapping", fname)
        else:
            file_map[fname] = fname

    # After this, all default selections should be populated
    # and the selections should be sane
    validate_selections(selections, mixin_tree)

    for src, dest in file_map.iteritems():
        dest_fn = os.path.join(product_dir, dest)
        clear_file(dest_fn)
        # dest_fn guaranteed to exist at this point and have the mixin
        # header/footer with no data in between

        # Now check all the groups to see if they have a configuration
        # fragment to insert into the destination file
        for group, option in selections:
            optdir = mixin_tree[group]["options"][option]
            src_fn = os.path.join(optdir, src)

            # Any given file can have multiple fragments. We first
            # look for <frag>.1, <frag>.2, ... <frag>.9, <frag>
            # This is useful for when several mixin options have mostly
            # the same data except for maybe a few lines; you can
            # avoid copypasting a lot of stuff by using this feature
            # and symbolic links for the common bits.
            frags = [src_fn + "." + str(i) for i in range(10)]
            frags.append(src_fn)

            for frag in frags:
                if os.path.exists(frag):
                    amend_file(dest_fn, frag, basedir)
    with open(os.path.join(product_dir, _HASH_FILE), "w") as fp:
        fp.write(mixins_hash)


def check_spec_file(specfile):
    cp = read_spec_file(specfile)
    basedir = cp.get("main", "mixinsdir")
    mixins_hash = hash_directory(specfile, basedir)
    product_dir = os.path.dirname(specfile)

    hfile = os.path.join(product_dir, _HASH_FILE);

    if not os.path.exists(hfile):
        sys.stderr.write("mixins.hash missing for {}\n".format(product_dir))
        return False

    with open(hfile) as fp:
        saved_hash = fp.read()

    if saved_hash != mixins_hash:
        sys.stderr.write("hashes don't match for {}\n".format(product_dir))
        return False
    return True


def find_all_spec_files(basepath):
    """find all the mixin spec files underneath the specified
    directory (typically device/) and return a list of paths to
    them"""
    ret = []
    for root, dirs, files in os.walk(basepath):
        if "mixins.spec" in files:
            ret.append(os.path.join(root, _PRODUCT_SPEC_FN))
    return ret


def main(dry_run=False, sfiles=None):
    ret = 0

    if not sfiles:
        sfiles = find_all_spec_files("device/intel")

    for sf in sfiles:
        if not check_spec_file(sf):
            ret = 1
            if not dry_run:
                print "Processing {}".format(sf)
                process_spec_file(sf)
            else:
                warning("{} needs to be updated".format(os.path.dirname(sf)))
        else:
            if not dry_run:
                print "{} appears to be up-to-date".format(sf)

    if dry_run:
        return ret
    return 0

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Update board configurations with mixin data based on spec file")
    parser.add_argument("-d", "--dry-run", help="Don't make any actual changes, exit nonzero if something needs to be updated",
            action="store_true")
    parser.add_argument("-s", "--spec", help="Read a specific spec file. Can be called multiple times. Defaults to scanning the tree under device/intel/ for spec files", action="append")
    args = parser.parse_args()

    ret = main(args.dry_run, args.spec)
    if ret:
        warning("Board configs are out of sync with mixins, please run mixin-update")
    sys.exit(ret)

